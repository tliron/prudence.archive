
prudence.include('../libraries/stickstick/data/')

import java.lang.System
import org.json.JSONObject

merge = { key, a, b ->
	if(!a.containsKey(key)) {
		return b[key]
	}
	else {
		return a[key]
	}
}

getId = { resource ->
    try {
        return Integer.parseInt(resource.resource.request.attributes.id)
    }
    catch(Exception) {
    	return null
    }

    //def form = resource.resource.request.resourceRef.queryAsForm
    //return Integer.valueOf(form.getFirstValue('id'))
}

handleInit = { resource ->
    resource.addMediaTypeByName('text/plain')
    resource.addMediaTypeByName('application/json')
}

handleGet = { resource ->
	def id = getId(resource)
	
    def note
    def connection = getConnection()
    try {
        note = getNote(id, connection)
        if(note == null) {
        	return 404
        }
    }
    finally {
    	connection.close()
    }

    resource.modificationTimestamp = note.timestamp
    note.remove('timestamp')
    return new JSONObject(note)
}

handleGetInfo = { resource ->
	def id = getId(resource)
	
    def note
    def connection = getConnection()
    try {
        note = getNote(id, connection)
        if(note == null) {
        	return null
        }
    }
    finally {
    	connection.close()
    }

    return note.timestamp
}

handlePost = { resource ->
	def id = getId(resource)

    // Note: You can only "consume" the entity once, so if we want it
    // as text, and want to refer to it more than once, we should keep
    // a reference to that text.
    
    def text = resource.entity.text
    def entity = new JSONObject(text)
    def note = [:]
	for(def key in entity.keys()) {
		note[key] = entity.get(key)
	}

    def connection = getConnection()
    try {
        def existing = getNote(id, connection)
        if(existing == null) {
        	return 404
        }
        note = [
        	id: id,
        	board: merge('board', note, existing),
        	x: merge('x', note, existing),
        	y: merge('y', note, existing),
        	size: merge('size', note, existing),
        	content: merge('content', note, existing)
        ]
        updateNote(note, connection)
        updateBoardTimestamp(note, connection)
    }
    finally {
    	connection.close()
    }

    resource.modificationTimestamp = note.timestamp
    note.remove('timestamp')
    return new JSONObject(note)
}

handleDelete = { resource ->
	def id = getId(resource)

    def connection = getConnection()
    try { 
        def note = getNote(id, connection)
        if(note == null) {
        	return 404
        }
        deleteNote(note, connection)
        updateBoardTimestamp(note, connection, System.currentTimeMillis())
    }
    finally {
    	connection.close()
    }

    return null
}

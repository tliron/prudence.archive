<%velocity #set($prudence.cacheDuration = 5000) #set($prefix = '../') %><%& '../fragments/header/' %>

<h2>Quick Tutorial</h2>

<h3>1. Run the Prudence Instance</h3>

<p>Prudence comes ready to rumble!</p>

<p>All you need is a Java Virtual Machine (JVM), minimally version 5.
Your operating system may already have one. Typing "java" from the
command line will usually tell you so.
Otherwise, an excellent, open-source JVM is available from the
<a href="http://openjdk.java.net/">OpenJDK</a> project.</p>

<div class="note">
<p>A Java Runtime Environment (JRE) is enough for Prudence. You need a
Java Development Kit (JDK) only if you plan to write code in Java.</p>

<p>A single installation of Prudence works as a container for
multiple applications and hosts, so there is rarely a need to install
it more than once per machine.</p>

<p>Also, Prudence does not require anything from Java Enterprise Edition (JEE).
In fact, you can see Prudence as a RESTful, minimal alternative to developing web
applications under JEE.</p>
</div>

<p>Try Prudence! Run /bin/run.sh for Unix-like systems (Linux and OS X), or /bin/run.bat for Windows.
Prudence should declare its version list the installed demo applications.
When it announces that it is listening on port 8080, it's ready to go.
Open your web browser to <a href="http://localhost:8080/">http://localhost:8080/</a>.
You should see the Prudence Administration application, where you can access the demos.
</p>

<div class="note">
<p>By the way: The /bin/run scripts are there for getting you quickly
up and running, however it is strongly recommended that you run
<a href="../daemon/">Prudence as a daemon</a> for production systems.
</p>
</div>


<h3>2. Your First Application</h3>

<p>Your Prudence instance hosts all applications under the /applications/ directory.
To install a new application, simply create a new subdirectory there.
The subdirectory name will be used as a default for various things: the base URL,
logging, etc. We can change those later.
</p>

<p>So, let's create /applications/wackywiki/</p>

<p>If you restart Prudence, you'll see wackywiki listed in the admin application.
There's nothing to see there quite yet, though.</p>

<div class="note>
<p>By the way: It's perfectly fine to use symbolic links or mounts to put your application
subdirectories elsewhere.</p>
</div>

<h3>3. A Static Web Page</h3>

<p>Create /applications/wackywiki/web/static/. Files you put there will served just like
from any static web server. You can put images, HTML files, CSS or anything else. Let's start
with a default web page.</p>

<p>/web/static/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;Nothing to see here, for now. Carry on.&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Restart Prudence, and browse to <a href="http://localhost:8080/wackiwiki/">http://localhost:8080/wackiwiki/</a>
to see the page.
</p>



<h3>4. A Dynamic Web Page</h3>

<div class="note">
<p>Important! While Prudence does dynamic web pages well, it really stands out
from other web frameworks in its support for REST resources, which we'll see in
the next section. We decided to start this tutorial with web pages, because the
topic would likely be more familiar to most newcomers to Prudence.</p>
</div>

<p>Create /applications/wackywiki/web/dynamic/. Unlike /web/static/, files in this
directory must be text files (HTML, XML, plain text, etc.) They are specially processed
so that they can include "scriptlets" of programming code.
</p>

<p>Let's move our index.html from /web/static/ to /web/dynamic/ and edit it to add some
Python scriptlets.</p> 

<p>/web/dynamic/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;It is currently
&lt;%python
from datetime import datetime
now = datetime.now()
print now.strftime('%H:%M')
%&gt;
o' clock, and
&lt;%
print now.strftime('%S')
%&gt;
seconds
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Restart Prudence, and browse to <a href="http://localhost:8080/wackiwiki/">http://localhost:8080/wackiwiki/</a>
to see the page.
</p>

<p>You'll notice the &lt;% and %&gt; are used to delimit scriptlets, and that we've
added "python" to the opening delimiter of the first scriptlet. Subsequent scriptlets
on the page will automatically use the language of the previous scriptlets, so we
don't have to repeat "python".</p>

<p>Note, too, that Python's "print" works by adding output to the stream of text where the
scriptlet is located.</p>

<p>Final note: Though they are conventionally called "scriptlets," they are not "scripts"
in the common meaning of interpreted code. All scriptlets are, in fact, compiled and run as
JVM bytecode. That's fast.</p>

<h4>Expressions</h4>

<p>Let's make our dynamic page more readable by using special "expression scriptlets."
They're really just a shorthand for "print."

<p>/web/dynamic/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;%python
from datetime import datetime
now = datetime.now()
%&gt;
It is currently &lt;%= now.strftime('%H:%M') %&gt; o' clock, and &lt;%= now.strftime('%S') %&gt; seconds
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>What happens if you have a coding error in your scriptlets? Let's try and introduce an error on purpose.</p>

<p>/web/dynamic/index.html:</p>
<pre>
...
from dratetime import datetime
...
</pre>

<p>If you try to browse to the page, Prudence will show you a detailed debug page,
from where you can also access the source code with the troublesome code line highlighted. Once you
deploy your application, you can cancel this debug feature. Also, you can show your own, custom,
user-friendly error pages. We'll get to that below.
</p>

<h4>Fragments</h4>

<p>Prudence lets you include others documents in-place using a special scriptlet. This makes it very easy
to reuse fragments of documents (which can include scriptlets) throughout your dynamic pages. Common reusbale
fragments are page headers, footers, and navigation menus.</p>

<p>By convention in Prudence, fragments are put in /web/fragments/, though you can include them from anywhere,
even from your regular /web/dynamic/ or /web/static/ subdirectories. The advantage of keeping them out of those
subdiretories is that users won't be able to access the individual fragments directly. Instead, we must explicitly
include them in our /web/dynamic/ files.
</p>

<p>Let's create a fragment that displays the current time.</p>

<p>/web/fragments/time.html:</p>
<pre>
&lt;%python
from datetime import datetime
now = datetime.now()
%&gt;
It is currently &lt;%= now.strftime('%H:%M') %&gt; o' clock, and &lt;%= now.strftime('%S') %&gt; seconds
</pre>

<p>/web/dynamic/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;&lt;%& '../fragments/time' %&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Note that the included scriptlet, which begins with the &lt;%& delimiter, accepts a real Python
expression. For example, you can do Pythony things like string interpolation: &lt;%& '%s-%s' % (language, encoding) %&gt;,
allowing you to include different fragments according to changing circumstances.
</p>

<h4>Caching</h4>

<p>Dynamically generating HTML and other text is very powerful. You may be wondering, however,
how well this scales. Even if the Python code is compiled, it would still need to be run for
every user request, right? Prudence supports straightforward per-page caching to greatly help
you scale. By changing document.cacheDuration within a scriptlet, you can dynamically change how
long Prudence will look for updates in the document. Note that even very short caching times
can be a great boost to scalability. For example, if your cache duration is 1 second, it means
that your scriptlets would only be run once every second. In computing terms, that's a very long
time! Imagine that your popular web site is getting 1000 hits per second...
</p>

<p>Finally, you'll be happy to know that by default Prudence also enables client-side caching.
It does this by setting a standard HTTP header that tells the client how long the content should
be cached. All popular desktop and mobile web browsers recognize it. This means
bandwidth savings for you, because the client will not download content it already has
in its cache.
</p>

<p>Let's enable a simple 60 second cache.</p>

<p>/web/dynamic/index.html:</p>
<pre>
&lt;% document.cacheDuration = 60000 %&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;&lt;%& '../fragments/time' %&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>To test the above, go to our page and keep refreshing it in your web browser. You will see
that the printed time will only be updated once every 10 seconds.</p>

<p>To verify that client-side caching works correctly, we recommend using the free Firefox
browser with the <a href="http://getfirebug.com/">Firebug</a> add-on. In the Firebug network panel,
you can see which
requests are sent to the server. Within those 60 seconds between updates, you will see the
that the request for the page returns a 304 status code: "the document has not been modified."
</p>

<p>For an even more elaborate experiment, try running two browsers at the same time on different
machines, and keep refreshing them. You'll see each client caching individually, and yet the
server still returning a different page only after the 60 second cache duration has passed.
</p>

<p>Caching is very powerful, but obviously not useful for all pages. For example, if it's
important for a page to always show the up-to-date to the moment information, you might not be able
to afford even a one second cache. It's useful, then, to know that Prudence's document.cacheDuration
works at the level of the actual document, so that each included fragment can set its own cache
duration. Just remember that the top document or fragment requests will determine the caching for
included fragments, too. If your index.html has a cache duration of 60 seconds, then even if
an included fragment has a cache duration of 1 second, it would only appear to update every
60 seconds.
</p>

<p>Scriptlets can also dynamically change the cache duration according to changing circumstances.
For example, under heavy load, you might want your application to cache for longer periods of
time.</p>

<h4>HTML Forms</h4>

<p>TODO</p>

<p>Let's allow users to edit our wacky wicki.
</p>

<pre>
form = prudence.resource.request.resourceRef.queryAsForm
fresh = form.getFirstValue('fresh') == 'true'
</pre>


<p>/web/fragments/wiki.html:</p>
<pre>
&lt;%python
wiki = 'Nothing in the wiki yet.'
%&gt;
Wiki content is: &lt;%= wiki %&gt;
</pre>

<p>/web/dynamic/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;&lt;%& '../fragments/time' %&gt;&lt;/div&gt;
&lt;div&gt;&lt;%& '../fragments/wiki' %&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<h4>More HTTP</h4>

<p>Prudence does a lot of the HTTP work automatically, but you can manipulate the response yourself.
For example, to redirect the client:
</p>

<pre>
prudence.resource.response.locationRef = prudence.resource.request.resourceRef.baseRef
prudence.statusCode = 303
raise
</pre>

<div class="note">
<p>Note the use of "raise": it's a handy trick to end processing of our page.
Prudence recognizes that we explicitly changed the status code, so it doesn't consider this to be a
real error.
</p>
</div>

<p>You can use also prudence.statusCode to explicitly set an error, for example to send
403 ("Forbidden") if the user is not logged in.
</p>

<p>Need more HTTP? Prudence supports HTTP cookies and HTTP authentication challenges.
We won't get into that in this tutorial, though.
</p>

<h4>Templating</h4>

<p>You might wonder what other options are available to you other than "python" for scriptlets.
You can choose other languages -- Ruby, JavaScript, Clojure, PHP, etc. -- if you have them installed.
But, more importantly, you can choose to use one of the pre-included templating languages, Succint and
Velocity.</p>

<p>Templating languages have far less features than any of the above programming languages, but
this can be an advantage if you all you need is simple templating. They tend to be more readable for
templates. Best of all, you can mix scriptlets from various languages in one page.
Here's an example of using Velocity and Python:</p> 

<p>/web/fragments/time.html:</p>
<pre>
&lt;%python
from datetime import datetime
now = datetime.now()
clock = now.strftime('%H:%M')
seconds = now.strftime('%S')
%&gt;
&lt;%velocity
It is currently $clock o' clock, and $seconds seconds
%&gt;
</pre>




<h3>5. A Resource</h3>

<p>As stated earlier, where Prudence truly shines is in its support for
REST resources. A resource is a piece of data associated with a URL, which
clients can optionally create, read, update or delete. An HTML web page is an example of a
resource which is usually read, and sometimes supports writing (for handling
HTML forms). Prudence lets you create resources that support one or more
formats, all create/read/update/delete (CRUD) operations, and advanced caching.
</p>

<p>A resource-oriented architecture is perfect for "AJAX" and other rich client platforms
(Flash, Silverlight, etc.).
Another use is for a scalable backend conduit between servers.
Depending on how you look at it, resources are either an online database,
an API for your service, or both.
</p>

<div class="note">
<p>You might want to take a look at <a href="../rest">Making the Case for REST</a>
for a better understanding of REST and what it can do for you.
</p>
</div>

<p>Let's start with a resource that can be read for some plain text. Resources
are put in the /resources/ subdirectory, and, like /web/dynamic/ and /web/static/,
the filename and directory tree define the URL:</p>

<p>/resources/wiki.py:</p>
<pre>
def handleInit():
    prudence.addMediaTypeByName('text/plain')

def handleGet():
    return 'Nothing in the wiki yet.'
</pre>

<p>handleInit() always gets called first, before any of the other handler functions.
</p>

<p>Try browsing to <a href="http://localhost:8080/wackywiki/wiki/">http://localhost:8080/wackywiki/wiki/</a>
to see your resource.</p>

<p>Plain text is good for us humans to read. But, we might want to support
formats that are more useful for client applications, such as <a href="http://www.json.org/">JSON</a> for
browser-based JavaScript or Flash's ActiveScript.
</p>

<p>Let's add support for JSON to our resource:</p>

<p>/resources/wiki.py:</p>
<pre>
wiki = 'Nothing in the wiki yet.'

def handleInit():
    prudence.addMediaTypeByName('text/plain')
    prudence.addMediaTypeByName('application/json')

def handleGet():
    if prudence.mediaTypeByName == 'text/plain':
        return wiki
    else:
        return '{"content": "%s"}' % wiki
</pre>

<p>[Add jQuery to dynamic page to test in browser.]</p>

<p>Just as /web/fragments/ was a useful place for us to put reusable web fragments,
we can use /libraries/ for reusable code for resources, as well as dynamic web
scriptlets. Let's create a library to handle our wiki:</p>

<p>/libraries/wiki.py:</p>
<pre>
wiki = 'Nothing in the wiki yet.'

def get_wiki():
    return wiki
</pre>

<p>Let's make use of our library in our resource:
</p>

<p>/resources/wiki.py:</p>
<pre>
sys.path.append('%s/../libraries/' % prudence.source.basePath)
from wiki import get_wiki

def handleInit():
    prudence.addMediaTypeByName('text/plain')
    prudence.addMediaTypeByName('application/json')

def handleGet():
    if prudence.mediaTypeByName == 'text/plain':
        return get_wiki()
    else:
        return '{"content": "%s"}' % get_wiki()
</pre>

<p>[Put, Post, Delete.]</p>

<p>/libraries/wiki.py:</p>
<pre>
from threading import RLock

wiki = 'Nothing in the wiki yet.'
wiki_lock = RLock()

def get_wiki():
    wiki_lock.acquire()
    try:
        return wiki
    finally:
        wiki_lock.release()

def set_wiki(content):
    wiki_lock.acquire()
    try:
        wiki = content
    finally:
        wiki_lock.release()
</pre>

<p>[Fixing our form handling from earlier using doPost.]</p>

<p>Remember how we supported client-side caching for our dynamic web pages?
We have much more control over this process in resources. We can set
explicit modification dates and ETags.
</p>

<p>Let's give our wiki resources a modification date, so that clients
can properly cache it:</p>

<p>/libraries/wiki.py:</p>
<pre>
from threading import RLock
from datetime import datetime

def to_milliseconds(dt):
    return long(mktime(dt.timetuple()) * 1000)

wiki = {content: 'Nothing in the wiki yet.', timestamp: datetime.now()}
wiki_lock = RLock()

def get_wiki():
    wiki_lock.acquire()
    try:
        # Note that we are returning a copy of our wiki dictionary!
        return {content: wiki['content'], timestamp: wiki['timestamp']}
    finally:
        wiki_lock.release()

def set_wiki(content):
    wiki_lock.acquire()
    try:
        wiki['content'] = content
        wiki['timestamp'] = datetime.now()
    finally:
        wiki_lock.release()
</pre>

<p>/resources/wiki.py:</p>
<pre>
sys.path.append(str(prudence.source.basePath) + '/../libraries/')
from wiki import get_wiki, set_wiki, to_milliseconds

def handleInit():
    prudence.addMediaTypeByName('text/plain')
    prudence.addMediaTypeByName('application/json')

def handleGet():
    wiki = get_wiki()
    prudence.modificationTimestamp = to_milliseconds(wiki['timestamp'])
    if prudence.mediaTypeByName == 'text/plain':
        return wiki['content']
    else:
        return '{"content": "%s"}' % wiki['content']
</pre>

<p>Support for modification date can go a long way towards saving us
bandwidth. However, note that we still have to fetch the entire wiki
in order to get its modification date. This could potentially be
a costly operation, say, if the wiki is stored in a database.
</p>

<p>Prudence lets you optimize this by letting you check only the
modification date (or ETag) before actually fetching the resource.
</p>

<p>Let's add handleGetInfo():</p>

<p>/resources/wiki.py:</p>
<pre>
sys.path.append(str(prudence.source.basePath) + '/../libraries/')
from wiki import get_wiki, set_wiki, to_milliseconds

def handleInit():
    prudence.addMediaTypeByName('text/plain')
    prudence.addMediaTypeByName('application/json')

def handleGet():
    wiki = get_wiki()
    prudence.modificationTimestamp = to_milliseconds(wiki['timestamp'])
    if prudence.mediaTypeByName == 'text/plain':
        return wiki['content']
    else:
        return '{"content": "%s"}' % wiki['content']

def handleGetInfo():
    wiki = get_wiki()
    return to_milliseconds(wiki['timestamp'])
</pre>

<p>Our trivial example didn't offer any significant savings. But, suppose our resource
involved fetching lots of wiki pages at once? We could save computing power if you we only
had to fetch a modification date.
</p>

<p>As we said earlier, our resources can be seen as an API. Indeed, there's no reason to
maintain two sets of APIs, one for "the world" to access via your resources, and one for
your application to use internally. You can use easily use your resources internally:</p> 

<p>/fragments/wiki.html:</p>
<pre>
&lt;%python
wiki = prudence.get('wiki', 'application/json');
wiki = eval('(' + wiki.text + ')')
%&gt;
Wiki content is: &lt;%= wiki['content'] %&gt;
</pre>

<p>The above is wasteful because we are turning the wiki data into JSON and then back again.
For internal API uses, it's possible to support direct access to the object:
</p>

<p>[ObjectRepresentation]</p>

<p>For completion, here's an example of how to access our resources from another Prudence-based
application:</p>

<p>/fragments/wiki.html:</p>
<pre>
&lt;%python
wiki = prudence.get('http://192.168.1.2/wackywiki/wiki', 'application/json');
wiki = eval('(' + wiki.text + ')')
%&gt;
Wiki content is: &lt;%= wiki['content'] %&gt;
</pre>



<h3>6. Advanced Routing</h3>

<p>Capturing URL patterns. Improve our resource above over the query params.</p>

<div class="note">By the way: Difference between URL and URI.</div>

<p>Virtual hosting, multiple servers.</p>

<p>Status handlers -- custom 404.</p>

<p>Just for fun: robots.txt, sitemap.xml.</p>



<h3>7. Other Features</h3>

<p>Logging.</p>

<p>Debug page.</p>

<p>Defrosting and pre-heating.</p>

<p>SSL.</p>

<p>Advanced representations. (Restlet extensions.)</p>

<%& '../fragments/footer/' %>
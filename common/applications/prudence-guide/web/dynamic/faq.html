<%velocity #set($prudence.cacheDuration = 5000) %><%& '../fragments/header/' %>

<h2>Frequently Asked Questions</h2>

<h3>Why are plural URL forms for aggregate resources (/animal/cats/) preferred over
singular forms (/animal/cat/)?</h3>

<p>You'll see RESTful implementations that use either convention. The advantage of using the singular
form is that you have less addresses, and what some people would call a more elegant scheme:
</p>
<pre>
/animal/cat/12 -> Just one cat
/animal/cat/ -> All cats
</pre>
<p>Why add another URL when a single one is enough to do the work?
</p>
<p>One reason is that you can help the client avoid potential errors. For example, the client probably
uses a variable to hold the ID of the cat and then constructs the URL dynamically. But, what if the client
forgets to check for null IDs? It might then construct a URL in the form "/animal/cat//" which
would then successfully access <i>all</i> cats. This can cause unintended consequences and be
difficult to debug. If, however, we used this scheme:
</p>
<pre>
/animal/cat/12 -> Just one cat
/animal/cats/ -> All cats
</pre>
<p>...then the form "/animal/cat//" would route to our singular cat resource, which would
indeed not find the cat and return the expected, debuggable 404 error.
</p>
<p>From this example, we can extract a good rule of thumb: clearly separate URLs at their base by usage,
so that mistakes cannot happen. More addresses means more debuggability.
</p>

<h3>How well does Prudence perform? How well does it scale?</h3>
<p>
First, recognize that there are two common uses for the term "scale." REST is often
referred to as an inherently scalable architecture, but that has more to do with
project management than technical performance. This difference is address in the
<a href="rest">Making the Case for REST</a>.
</p>

<p>From the perspective of the ability to respond to user requests, there are three
aspects to consider:
</p>

<h4>1. Serving HTTP</h4>
<p>
Prudence comes with <a href="https://grizzly.dev.java.net/">Grizzly</a>,
an HTTP server based on the JVM's non-blocking I/O API. Grizzly handles concurrent HTTP
requests very well, and serves static files at scales comparable to popular HTTP servers.
See the <a href="../guide/static-web/">tutorial</a> for more information.
</p>

<h4>2. Generating HTML</h4>
<p>
Prudence supports two modes for generating HTML (and other textual formats), each with its own performance characteristics:
</p><p>
<i>Caching mode:</i> First, the entire document is run, with its output sent into a buffer. This buffer is then cached,
and <i>only then</i> sent to the client. This is the default mode and recommended for most documents. Scriptlets can be
used to control the duration of the document's individual cache.  
</p><p>
<i>Streaming mode:</i> Output is sent to the client <i>while</i> the document runs. This is recommended for documents
that need to output a very large amount of text, which might take a long time, or that might otherwise encounter slow-downs
while running. In either case, you want the client to receive ongoing output. The output of the document is not cached.
</p><p>
Scriptlets can be used switch between modes according to changing circumstances. For example, to increase caching duration
during heavy loads, to decrease it during periods where data changes often, or to stream in the case of an expected large output.
See the <a href="../guide/dynamic-web">tutorial</a> for more information.
</p>

<h4>3. Running code</h4>
<p>
There may be a delay when starting up a specific language engine in Prudence for the first time in an application, as it loads
and initializes itself. Then, there may be a delay when accessing a dynamic web page or resource for the first time, or after
it has been changed, as it might require compilation. Once it's up and running, though, your code performs and scale very well --
as well as you've written it. You need to understand concurrency and make sure you make good choices to handle
coordination between threads accessing the same data. If all is good, your code will actually perform better throughout the
life of the application. The JVM learns and adapts as it runs, and performance can improve the more the application is used. 
</p>
<p>
If you are performing CPU-intensive or time-sensitive tasks, then it's best to profile these code segments precisely.
Exact performance characteristics depend on the language and engine used. The <a href="http://shootout.alioth.debian.org/">Bechmarks Game</a>
can give you some comparisons of different language engines running high-computation programs.
In any case, if you have a piece of intensive code that really needs to perform well, it's probably best to write
it in Java and access it from the your language. You can even write it in C or assembly, and have it linked to Java via JNI.
</p>
<p>
If you're not doing intensive computation, then don't worry too much about your language being "slow." It's been shown that for the
vast majority of web applications, the performance of the web programming language is rarely the bottleneck. The deciding factors are
the usually performance of the backend data-driving technologies and architectures.
</p> 

<%& '../fragments/footer/' %>
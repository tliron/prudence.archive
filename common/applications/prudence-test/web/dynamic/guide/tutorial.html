<%velocity #set($document.cacheDuration=5000) #set($prefix = '../') %><%& '../fragments/header' %>

<h2>Quick Tutorial</h2>

<p>This is a show-and-tell session going through Prudence's main features.
Far more detailed explanations are given in the Prudence guide.</p>

<div class="note">
<p>For now, this is a todo list...</p>
</div>

<h3>1. Run the Prudence Instance</h3>

<p>Quick look at the administration application.</p>

<h3>2. Your First Application</h3>

<p>Your Prudence instance will host all applications under the /applications/ directory.
Simply create a new subdirectory there. The subdirectory name will be used as a default
for various things we can change later.
</p>

<p>So, let's create /applications/wackywiki/</p>

<h3>3. A Static Web Page</h3>

<p>Create /applications/wackywiki/web/static/. Files you put there will served just like
from any static web server. You can put images, HTML files, CSS or anything else. Let's start
with a default web page.</p>

<p>/web/static/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;Nothing to see here, for now. Carry on.&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Restart Prudence, and browse to http://localhost:8080/wackiwiki to see the page.
You can also see it at http://localhost:8080/wackiwiki/index.html. 
Check the Prudence administration application at http://localhost:8080/ to make
sure your new application is there.
</p>

<h3>4. A Dynamic Web Page</h3>

<p>(This is cool, but check out resources, below.)</p>

<p>Create /applications/wackywiki/web/dynamic/. Unlike /web/static/, files in this
directory must be text files (HTML, XML, plain text, etc.) They are specially processed
so that they can include "scriptlets" of programming code.
</p>

<p>Let's move our index.html from /web/static/ to /web/dynamic/ and edit it to add some
Python scriptlets.</p> 

<p>/web/dynamic/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;It is currently
&lt;%python
from datetime import datetime
now = datetime.now()
print now.strftime('%H:%M')
%&gt;
o' clock, and
&lt;%
print now.strftime('%S')
%&gt;
seconds
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>You'll notice the &lt;% and %&gt; are used to delimit scriptlets, and that we've
added "python" to the opening delimiter of the first scriptlet. Subsequent scriptlets
on the page will automatically use the language of the previous scriptlets, so we
don't have to repeat it.</p>

<p>Note, too, that "print" works by adding output to the stream of text where the
scriptlet is located.</p>

<p>Final note: Though they are called "scriptlets," they are not "scripts," in the
common meaning of interpreted code. All scriptlets are, in fact, compiled and run in
JVM bytecode. That's fast.</p>

<p>Let's make the code above more readable by using special "expression scriptlets."
They're really just a shorthand for "print."

<p>/web/dynamic/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;%python
from datetime import datetime
now = datetime.now()
%&gt;
It is currently &lt;%= now.strftime('%H:%M') %&gt; o' clock, and &lt;%= now.strftime('%S') %&gt; seconds
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>What happens if you have a coding error in your scriptlets? Let's try and introduce an error on purpose.</p>

<p>/web/dynamic/index.html:</p>
<pre>
...
from dratetime import datetime
...
</pre>

<p>If you try to access http://localhost:8080/wackywiki, Prudence will show you a very detailed debug page,
from where you can also access the source code with the troublesome code line highlighted. Once you
deploy your application, you can cancel this debug feature.
</p>

<p>Prudence lets you include others documents in-place using a special scriptlet. This makes it very easy
to reuse fragments of documents (which can include scriptlets) throughout your dynamic pages. Common uses
are page headers, footers, and navigation menus.</p>

<p>By convention in Prudence, fragments are put in /web/fragments/, though you can include them from anywhere,
even from your regular /web/dynamic/ or /web/static/ subdirectories. The advantage of keeping them out of there
is that users won't be able to access the individual fragments directly. Instead, we must explicitly include
them in our /web/dynamic/ files.
</p>

<p>Let's create a fragment that displays the current time.</p>

<p>/web/fragments/time.html:</p>
<pre>
&lt;%python
from datetime import datetime
now = datetime.now()
%&gt;
It is currently &lt;%= now.strftime('%H:%M') %&gt; o' clock, and &lt;%= now.strftime('%S') %&gt; seconds
</pre>

<p>/web/dynamic/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;&lt;%& '../fragments/time' %&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Note that the include scriptlet, which begins with the &lt;%& delimiter, accepts a real Python
expression. For example, you can do Pythony things like &lt;%& '%s-%s' % (language, encoding) %&gt;,
allowing you to include specific fragments according to dynamic circumstances.
</p>

<p>Accessing the query.</p>

<p>Dynamically generating HTML and other text is very powerful. You may be wondering, however,
how well this scales. Even if the Python code is compiled, it would still need to be run for
every user request, right? Prudence supports straightforward per-page caching to greatly help
you scale. By changing document.cacheDuration within a scriptlet, you can dynamically change how
long Prudence will look for updates in the document. Note that even very short caching times
can be a great boost to scalability. For example, if your cache duration is 1 second, it means
that your scriptlets would only be run once every second. In computing terms, that's a very long
time! For example, imagine that your popular web site is getting 1000 hits per second...
</p>

<p>Finally, you'll be happy to know that by default Prudence also enables client-side caching.
It does this by setting a standard HTTP header that tells the client how long the content should
be cached. All popular web browsers recognize it. This can mean significant bandwidth savings for
you, because the client will not send an unnecessary request that would return the same content
from you.
</p>

<p>Let's enable a simple 10 second cache.</p>


<p>/web/dynamic/index.html:</p>
<pre>
&lt;% document.cacheDuration = 10000 %&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;&lt;%& '../fragments/time' %&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>To test the above, go to our page and keep refreshing it in your web browser. You will see
that the printed time will only be udpated once every 10 seconds.</p>

<p>To verify that client-side caching works correctly, we reccommed using the free Firefox
browser with the amazing Firebug add-on. In the Firebug network panel, you can see which
requests are sent to the server. Within those 10 seconds between updates, you will see the
that the request for the page returns a 304 status code: "the document has not been modified."
</p>

<p>For an even more elaborate experiment, try running two browsers at the same time on different
machines, and keep refreshing them. You'll see each client caching individually, and yet the
server still returning a different page only after the 10 second cache duration has passed.
</p>

<p>Caching is very powerful, but obviously only useful for specific pages. For example, if it's
important for a page to always show the up-to-date to the moment information, you might not be able
to afford even a one second cache. It's useful, then, to know that Prudence's document.cacheDuration
works at the level of the current document, so that each included fragment can set its own cache
duration. Just remember that the top document or fragment requests will determine the caching for
included fragments, too. If your index.html has a cache duration of 10 seconds, then even if
an included fragment has a cache duration of 1 second, it would only appear to update every
10 seconds.
</p>

<p>Scriptlets can also dynamically change the cache duration according to changing circumstances.
For example, under heavy load, you might want your application to cache for longer periods of
time.</p>

<p>Handling an HTML form.</p>

<p>/web/fragments/wiki.html:</p>
<pre>
&lt;%python
wiki = 'Nothing in the wiki yet.'
%&gt;
Wiki content is: &lt;%= wiki %&gt;
</pre>

<p>/web/dynamic/index.html:</p>
<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Wacky Wiki&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;&lt;%& '../fragments/time' %&gt;&lt;/div&gt;
&lt;div&gt;&lt;%& '../fragments/wiki' %&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Quick peek at Velocity/Succinct.</p>

<p>/web/fragments/time.html:</p>
<pre>
&lt;%python
from datetime import datetime
now = datetime.now()
clock = now.strftime('%H:%M')
seconds = now.strftime('%S')
%&gt;
&lt;%velocity
It is currently $clock o' clock, and $seconds seconds
%&gt;
</pre>

<h3>5. A Resource</h3>

<p>Return a string.</p>

<p>/resources/wiki.py:</p>
<pre>
def handleInit():
    prudence.addMediaTypeByName('text/plain')

def handleGet():
    return 'Nothing in the wiki yet.'
</pre>

<p>Return text or JSON. Use query params.</p>

<p>/resources/wiki.py:</p>
<pre>
wiki = 'Nothing in the wiki yet.'

def handleInit():
    prudence.addMediaTypeByName('text/plain')
    prudence.addMediaTypeByName('application/json')

def handleGet():
    if prudence.mediaTypeByName == 'text/plain':
        return wiki
    else:
        return '{"content": "%s"}' % wiki
</pre>

<p>Test in a browser. Add jQuery to dynamic page to test in browser.</p>

<p>You might want to take a look at <a href="../rest">Making the Case for REST</a>.
</p>

<p>Including from /libraries.</p>

<p>/libraries/wiki.py:</p>
<pre>
wiki = 'Nothing in the wiki yet.'

def get_wiki():
    return wiki
</pre>

<p>/resources/wiki.py:</p>
<pre>
sys.path.append(str(prudence.source.basePath) + '/../libraries/')
from wiki import get_wiki, set_wiki

def handleInit():
    prudence.addMediaTypeByName('text/plain')
    prudence.addMediaTypeByName('application/json')

def handleGet():
    if prudence.mediaTypeByName == 'text/plain':
        return get_wiki()
    else:
        return '{"content": "%s"}' % get_wiki()
</pre>

<p>Put, Post, Delete.</p>

<p>/libraries/wiki.py:</p>
<pre>
from threading import RLock

wiki = 'Nothing in the wiki yet.'
wiki_lock = RLock()

def get_wiki():
    wiki_lock.acquire()
    try:
        return wiki
    finally:
        wiki_lock.release()

def set_wiki(content):
    wiki_lock.acquire()
    try:
        wiki = content
    finally:
        wiki_lock.release()
</pre>

<p>Fixing our form handling from earlier using doPost.</p>

<p>Caching (modification dates and ETags).</p>

<p>/libraries/wiki.py:</p>
<pre>
from threading import RLock
from datetime import datetime

def to_milliseconds(dt):
    return long(mktime(dt.timetuple()) * 1000)

wiki = {content: 'Nothing in the wiki yet.', timestamp: datetime.now()}
wiki_lock = RLock()

def get_wiki():
    wiki_lock.acquire()
    try:
        # Note that we are returning a copy of our wiki dictionary!
        return {content: wiki['content'], timestamp: wiki['timestamp']}
    finally:
        wiki_lock.release()

def set_wiki(content):
    wiki_lock.acquire()
    try:
        wiki['content'] = content
        wiki['timestamp'] = datetime.now()
    finally:
        wiki_lock.release()
</pre>

<p>/resources/wiki.py:</p>
<pre>
sys.path.append(str(prudence.source.basePath) + '/../libraries/')
from wiki import get_wiki, set_wiki, to_milliseconds

def handleInit():
    prudence.addMediaTypeByName('text/plain')
    prudence.addMediaTypeByName('application/json')

def handleGet():
    wiki = get_wiki()
    prudence.modificationTimestamp = to_milliseconds(wiki['timestamp'])
    if prudence.mediaTypeByName == 'text/plain':
        return wiki['content']
    else:
        return '{"content": "%s"}' % wiki['content']
</pre>

<p>Optimizing with handleGetInfo.</p>

<p>/resources/wiki.py:</p>
<pre>
sys.path.append(str(prudence.source.basePath) + '/../libraries/')
from wiki import get_wiki, set_wiki, to_milliseconds

def handleInit():
    prudence.addMediaTypeByName('text/plain')
    prudence.addMediaTypeByName('application/json')

def handleGet():
    wiki = get_wiki()
    prudence.modificationTimestamp = to_milliseconds(wiki['timestamp'])
    if prudence.mediaTypeByName == 'text/plain':
        return wiki['content']
    else:
        return '{"content": "%s"}' % wiki['content']

def handleGetInfo():
    wiki = get_wiki()
    return to_milliseconds(wiki['timestamp'])
</pre>

<p>Direct access to resources (ClientResource). Back to dynamic HTML - using your resources there.</p> 

<p>/fragments/wiki.html:</p>
<pre>
&lt;%python
from com.threecrickets.prudence import Resource
wiki = Resource.get('wiki', 'application/json');
wiki = eval('(' + wiki.text + ')')
%&gt;
Wiki content is: &lt;%= wiki['content'] %&gt;
</pre>

<p>External resources: distributing your application.</p>

<p>/fragments/wiki.html:</p>
<pre>
&lt;%python
from com.threecrickets.prudence import Resource
wiki = Resource.getExternal('http://192.168.1.2/wackywiki/wiki', 'application/json');
wiki = eval('(' + wiki.text + ')')
%&gt;
Wiki content is: &lt;%= wiki['content'] %&gt;
</pre>

<h3>6. Advanced Routing</h3>

<p>URL patterns. Improve our resource above over the query params.</p>

<p>Virtual hosting, multiple servers.</p>

<p>URL rewriting.</p>

<p>Status handlers -- custom 404.</p>

<p>Just for fun: robots.txt, sitemap.xml.</p>

<h3>7. Other Features</h3>

<p>Logging.</p>

<p>Debug page.</p>

<p>Defrosting and pre-heating.</p>

<p>SSL.</p>

<p>Advanced representations. (Restlet extensions.)</p>

<%& '../fragments/footer' %>